<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
/*
* 函数作用域
*     --调用函数时创建函数作用域,函数执行完毕后作用域销毁
*     --每调用一次函数就会创建一个新的函数作用域,他们之间是相互独立的
*     --在函数作用域中函数可以访问全局作用域的变量,全局作用域函数无法访问得到函数作用域中的变量
*     --当在函数作用域操作一个变量时,他会先在自身作用域中寻找,如果有就之间使用,如果没有就向上一级作用域里面找
*        如果在全局作用域里面还没有找到就会报错
*     --在函数中要访问全局变量可以使用window对象相当于this
*
*     在函数作用域也有声明的特性
*       使用var关键字声明变量,会在函数中所有的代码执行之前被声明
*       函数声明也会在函数中所有的代码执行之前执行
*
* */
   //创建一个变量
var a = 10;

  function fun() {
  var a = "我是函数中的a "
  var b = 20;
   console.log("a = " + a);
   //console.log("a =" + window.a) 这样就可以 获取到a = 10了
  }
  // fun();0.
  // fun();
  // fun(); 创建了三个函数作用域
 fun(); // 他可以访问到a
 //console.log( "b = "+ b); 这是一个全局作用域,他不可以访问得到函数里的数据
 console.log(" a = "+a);
 function fun3() {
     fun4(); // 这是可以正常运行的因为他相当于一个全局变量
     var a;
     // console.log(a); //他会报错因为变量被提前了
     // var a = 35; 相当于下面的这种情况
      a = 35;

      function fun4() {  //这是一个函数声明
          alert("我可以正常运行")
      }
 }

 var c = 33;
 function fun5() {
     console.log("c = " +c)  //最后输出33 因为他会向上一级一级的找
     var c = 10;  //这样他会输出Undefine d,因为 var c 会被提前有数但没被赋值
        c = 10 ; //没有上面的  var c = 10; 只有 c = 10在这样的情况下最众速出的是 33
     d = 100
 }
  fun5();
 //在全局输出c
console.log("c =" +c); //最终输出的是 10 ,因为c = 10相当于全局的
                       //在函数中,不使用var声明的变量都会成为全局变量,优先级最高
console.log("d ="+d); //最终输出d = 100; 这个d 相当于window.d 全局变量

  var e = 23;
  function fun6(e) {

      alert(e);
  }
  fun6() //最终输出的是undefined

</script>
</html>
